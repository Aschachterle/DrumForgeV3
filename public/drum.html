<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/images/logo.png">
    <link rel="stylesheet" href="/css/common.css">
    <link rel="stylesheet" href="/css/drum.css">
    <title>Parametric Drum - Extrudo</title>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="/" class="back-link">
                ‚Üê Back to Models
            </a>
            <img class="header-logo" src="/images/logo.png" alt="Extrudo logo">
        </div>

        <div class="layout">
            <div class="panel">
                <img class="hero-image" src="/images/gallery/printed-drum.png" alt="3D printed drum shell">
                <div class="panel-header">Electronic Drum Forge</div>
                <p class="description">Welcome to the Extrudo E-Drum modeler. I built this tool as a proof of concept using Fusion 360's API and Autodesk's Design Automation service. You can modify the drum parameters below to create a custom 3d printable E-drum shell along with a matching sensor platform. Once you are happy with your drum size, lug spacing, and other parameters, you can generate the final STL file for 3D printing. Currently I only have a developer license so once my API usage limits are reached it may stop processing requests until the limit resets.</p>

                <!-- Parameters Section -->
                <div class="section">
                    <div class="section-title">
                        <div class="section-icon">1</div>
                        Modify Parameters
                    </div>
                    <div class="parameters-grid" id="parametersGrid">
                        <!-- Will be filled by JavaScript -->
                    </div>
                </div>

                <!-- Submit Section -->
                <div class="section">
                    <div class="section-title">
                        <div class="section-icon">2</div>
                        Process Your Drum
                    </div>
                    <div class="validation-summary" id="validationSummary">
                        Please fix the highlighted parameters before generating.
                    </div>
                    <div class="button-group">
                        <button class="btn-submit" id="submitBtn">
                            Generate Modified Drum
                        </button>
                        <button class="btn-secondary" id="resetBtn">Reset Parameters</button>
                    </div>
                </div>

                <!-- Status Section -->
                <div class="status" id="status">
                    <div class="status-text" id="statusText"></div>
                    <div class="progress" id="progress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                    </div>
                    <div id="statusDetails"></div>
                    <div id="downloadSection" style="display: none; margin-top: 15px;">
                        <button class="btn-submit" id="downloadBtn" style="width: 100%;">
                            Download Modified Drum File
                        </button>
                    </div>
                </div>

            </div>

            <div class="panel">
                <div class="panel-header">Preview</div>
                <div class="preview-frame" id="previewFrame">
                    <div class="preview-empty" id="previewEmpty">Loading preview...</div>
                    <img id="previewImage" alt="Modified drum preview">
                </div>
                <div class="preview-actions">
                    <span>Preview updates as you adjust parameters.</span>
                    <a id="previewLink" class="preview-link" href="#" target="_blank" rel="noopener" style="display:none;">Open full size</a>
                </div>
            </div>
        </div>

        <!-- Example Gallery Section -->
        <div class="gallery-section">
            <div class="gallery-header">
                <h2>What You'll Get</h2>
                <p>See examples of generated drum shells and what they look like printed.</p>
            </div>
            <div class="gallery-grid">
                <div class="gallery-item">
                    <img src="/images/gallery/fusion-preview.png" alt="Fusion 360 model preview">
                    <div class="gallery-caption">
                        <strong>STL Output Example</strong>
                        <span>The STL file ready for 3D printing</span>
                    </div>
                </div>
                <div class="gallery-item">
                    <img src="/images/gallery/printed-drum.png" alt="Fusion 360 model preview">
                    <div class="gallery-caption">
                        <strong>Printed and Assembled Example</strong>
                        <span>A 3D printed and assembled drum shell</span>
                    </div>
                </div>
                <!-- Future gallery items for 3D printed examples -->
                <!--
                <div class="gallery-item">
                    <img src="/images/gallery/print-example-1.jpg" alt="3D printed drum shell">
                    <div class="gallery-caption">
                        <strong>3D Printed Shell</strong>
                        <span>PLA, 0.2mm layer height</span>
                    </div>
                </div>
                -->
            </div>
        </div>

        <!-- Image Lightbox Modal -->
        <div id="lightboxModal" class="lightbox-modal">
            <span class="lightbox-close">&times;</span>
            <img class="lightbox-image" id="lightboxImage" alt="">
            <div class="lightbox-caption" id="lightboxCaption"></div>
        </div>

        <!-- Assembly Instructions Section (hidden until real images are added) -->
        <div class="instructions-section" style="display: none;">
            <div class="instructions-header">
                <h2>Assembly Instructions</h2>
                <p>Follow these steps to assemble your 3D printed drum shell.</p>
            </div>
            <div class="instructions-grid">
                <div class="instruction-step">
                    <div class="step-number">1</div>
                    <div class="step-image">
                        <img src="/images/instructions/step1-print.png" alt="Print the segments">
                        <div class="placeholder-text">Image coming soon</div>
                    </div>
                    <div class="step-content">
                        <h3>Print the Segments</h3>
                        <p>Print all shell segments using your preferred material. PLA or PETG works well. Use 15-20% infill and 0.2mm layer height for best results.</p>
                    </div>
                </div>
                <div class="instruction-step">
                    <div class="step-number">2</div>
                    <div class="step-image">
                        <img src="/images/instructions/step2-sand.png" alt="Sand the edges">
                        <div class="placeholder-text">Image coming soon</div>
                    </div>
                    <div class="step-content">
                        <h3>Sand the Lap Joints</h3>
                        <p>Lightly sand the lap joint surfaces to ensure a snug fit. Test fit the segments before gluing.</p>
                    </div>
                </div>
                <div class="instruction-step">
                    <div class="step-number">3</div>
                    <div class="step-image">
                        <img src="/images/instructions/step3-glue.png" alt="Glue segments together">
                        <div class="placeholder-text">Image coming soon</div>
                    </div>
                    <div class="step-content">
                        <h3>Glue the Segments</h3>
                        <p>Apply CA glue or epoxy to the lap joints and press segments together. Use clamps or rubber bands to hold while curing.</p>
                    </div>
                </div>
                <div class="instruction-step">
                    <div class="step-number">4</div>
                    <div class="step-image">
                        <img src="/images/instructions/step4-hardware.png" alt="Install hardware">
                        <div class="placeholder-text">Image coming soon</div>
                    </div>
                    <div class="step-content">
                        <h3>Install Hardware</h3>
                        <p>Insert lug inserts and mount your mesh head hardware. The lug holes are pre-positioned for standard e-drum spacing.</p>
                    </div>
                </div>
                <div class="instruction-step">
                    <div class="step-number">5</div>
                    <div class="step-image">
                        <img src="/images/instructions/step5-sensor.png" alt="Mount sensor platform">
                        <div class="placeholder-text">Image coming soon</div>
                    </div>
                    <div class="step-content">
                        <h3>Mount Sensor Platform</h3>
                        <p>Attach the sensor platform (generated separately) to the inside of the shell. Connect your piezo trigger.</p>
                    </div>
                </div>
                <div class="instruction-step">
                    <div class="step-number">6</div>
                    <div class="step-image">
                        <img src="/images/instructions/step6-finish.png" alt="Final assembly">
                        <div class="placeholder-text">Image coming soon</div>
                    </div>
                    <div class="step-content">
                        <h3>Final Assembly</h3>
                        <p>Tension the mesh head evenly and connect to your drum module. Your custom e-drum is ready to play!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let config = {};
        let currentJobId = null;
        let previewRefreshTimer = null;
        let previewObjectUrl = null;
        let previewRequestInFlight = false;
        let livePreviewDebounce = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await loadConfig();
            setupEventListeners();
            // Show live preview immediately
            updateLivePreview();
        });

        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                config = await response.json();
                renderParameters();
            } catch (error) {
                console.error('Error loading config:', error);
                showStatus('Error loading configuration', 'error');
            }
        }

        function getParameters() {
            const parameters = {};
            for (const [key, param] of Object.entries(config.parameters)) {
                const input = document.getElementById(key);
                if (input) {
                    let value = input.value;
                    
                    // Check if this parameter has a toggle and is disabled
                    if (param.toggleable) {
                        const checkbox = document.getElementById(`${key}_enabled`);
                        if (checkbox && !checkbox.checked) {
                            // Use the disabled value when unchecked
                            value = `${param.disabledValue} ${param.unit}`;
                            parameters[key] = value;
                            continue;
                        }
                    }
                    
                    if (param.type === 'number') {
                        value = parseFloat(value);
                    } else if (param.type === 'dimension') {
                        // Append unit to numeric value for dimension fields
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            value = `${numValue} ${param.unit}`;
                        }
                    }
                    parameters[key] = value;
                }
            }
            return parameters;
        }

        // Parse dimension string like "12 in" or "6 mm" to a number (converted to inches)
        function parseDimension(value, defaultVal = 0) {
            if (typeof value === 'number') return value;
            if (!value) return defaultVal;
            const str = String(value).trim().toLowerCase();
            const match = str.match(/^([\d.]+)\s*(in|inch|inches|mm|cm|m)?$/i);
            if (!match) return defaultVal;
            let num = parseFloat(match[1]);
            const unit = match[2] || 'in';
            if (unit === 'mm') num /= 25.4;
            else if (unit === 'cm') num /= 2.54;
            else if (unit === 'm') num *= 39.37;
            return num || defaultVal;
        }

        // Build SVG preview with Top, Side, and Piezo Sensor Platform views
        function buildPreviewSvg(parameters) {
            const p = parameters || {};

            // Parse dimensions
            const diam = parseDimension(p.ShellDiam, 12);
            const height = parseDimension(p.ShellHeight, 6);
            const thick = parseDimension(p.ShellThick, 0.25);
            const thickMm = (thick * 25.4).toFixed(1);
            const segments = parseInt(p.NumSegments, 10) || 2;
            const lugTop = parseDimension(p.LugTopDist, 2);
            const lugSpace = parseDimension(p.LugSpacing, 2);
            const lapPct = parseFloat(p.LapSizePercent) || 22;
            const lugDiam = parseDimension(p.LugHoleDiam, 0.25);
            const outputHoleDiam = parseDimension(p.OutputHoleDiam, 0.375);
            const outputHoleEnabled = outputHoleDiam > 0.01;

            // Scale: 8px per inch
            const scale = 8;
            const maxDim = 20;
            const clampedDiam = Math.min(diam, maxDim);
            const clampedHeight = Math.min(height, maxDim);

            const topRadius = (clampedDiam * scale) / 2;
            const sideWidth = clampedDiam * scale;
            const sideHeight = clampedHeight * scale;
            const thickPx = Math.max(2, thick * scale);
            const lugR = Math.max(2, (lugDiam * scale) / 2);

            // Layout
            const padding = 50;
            const leftMargin = 55;
            const topCx = leftMargin + topRadius;
            const topCy = padding + topRadius;
            const sideX = leftMargin;
            const sideY = padding + topRadius * 2 + 75;
            const platformCx = topCx;
            const platformCy = sideY + sideHeight + 100 + topRadius;

            const svgWidth = topCx + topRadius + 60;
            const svgHeight = platformCy + topRadius + 50;

            const visualThickPx = Math.min(thickPx, topRadius / 4);
            const innerRadius = topRadius - visualThickPx;

            // Platform calculations
            const centerCircleMm = 37;
            const centerCircleInches = centerCircleMm / 25.4;
            const centerCircleRadiusPx = (centerCircleInches / 2) * scale;
            const platformOuterArcDeg = (360 * 2) / (Math.PI * diam);
            const platformInnerArcDeg = (360 * 6) / (Math.PI * diam);

            const platformCenterAngle = -90;
            const outerStartAngle = platformCenterAngle - platformOuterArcDeg / 2;
            const outerEndAngle = platformCenterAngle + platformOuterArcDeg / 2;
            const innerStartAngle = platformCenterAngle - platformInnerArcDeg / 2;
            const innerEndAngle = platformCenterAngle + platformInnerArcDeg / 2;

            const outerStartRad = (outerStartAngle * Math.PI) / 180;
            const outerEndRad = (outerEndAngle * Math.PI) / 180;
            const innerStartRad = (innerStartAngle * Math.PI) / 180;
            const innerEndRad = (innerEndAngle * Math.PI) / 180;

            const platformOuterRadius = innerRadius;
            const pOuterStartX = platformCx + platformOuterRadius * Math.cos(outerStartRad);
            const pOuterStartY = platformCy + platformOuterRadius * Math.sin(outerStartRad);
            const pOuterEndX = platformCx + platformOuterRadius * Math.cos(outerEndRad);
            const pOuterEndY = platformCy + platformOuterRadius * Math.sin(outerEndRad);
            const pInnerStartX = platformCx + centerCircleRadiusPx * Math.cos(innerStartRad);
            const pInnerStartY = platformCy + centerCircleRadiusPx * Math.sin(innerStartRad);
            const pInnerEndX = platformCx + centerCircleRadiusPx * Math.cos(innerEndRad);
            const pInnerEndY = platformCy + centerCircleRadiusPx * Math.sin(innerEndRad);

            const platformPath = `M${pOuterStartX},${pOuterStartY} A${platformOuterRadius},${platformOuterRadius} 0 0,1 ${pOuterEndX},${pOuterEndY} L${pInnerEndX},${pInnerEndY} A${centerCircleRadiusPx},${centerCircleRadiusPx} 0 0,0 ${pInnerStartX},${pInnerStartY} Z`;

            // Top view: pie slices and cut lines
            let topPieSlices = '';
            let topCutLines = '';
            const segAngle = 360 / segments;
            const midRadius = topRadius - visualThickPx / 2;
            const lapAngleDeg = segAngle * (lapPct / 100);

            for (let i = 0; i < segments; i++) {
                const startAngle = i * segAngle;
                const endAngle = (i + 1) * segAngle;
                const startRad = (startAngle * Math.PI) / 180;
                const endRad = (endAngle * Math.PI) / 180;

                const outerStartX = topCx + topRadius * Math.cos(startRad);
                const outerStartY = topCy + topRadius * Math.sin(startRad);
                const outerEndX = topCx + topRadius * Math.cos(endRad);
                const outerEndY = topCy + topRadius * Math.sin(endRad);
                const innerStartX = topCx + innerRadius * Math.cos(startRad);
                const innerStartY = topCy + innerRadius * Math.sin(startRad);
                const innerEndX = topCx + innerRadius * Math.cos(endRad);
                const innerEndY = topCy + innerRadius * Math.sin(endRad);

                const largeArc = segAngle > 180 ? 1 : 0;
                const fill = i % 2 === 0 ? '#f5f5f5' : '#fff';
                topPieSlices += `<path d="M${outerStartX},${outerStartY} A${topRadius},${topRadius} 0 ${largeArc},1 ${outerEndX},${outerEndY} L${innerEndX},${innerEndY} A${innerRadius},${innerRadius} 0 ${largeArc},0 ${innerStartX},${innerStartY} Z" fill="${fill}" stroke="none"/>`;
            }

            for (let i = 0; i < segments; i++) {
                const angle = i * segAngle;
                const angleRad = (angle * Math.PI) / 180;
                const outerX = topCx + topRadius * Math.cos(angleRad);
                const outerY = topCy + topRadius * Math.sin(angleRad);
                const innerX = topCx + innerRadius * Math.cos(angleRad);
                const innerY = topCy + innerRadius * Math.sin(angleRad);
                const midX = topCx + midRadius * Math.cos(angleRad);
                const midY = topCy + midRadius * Math.sin(angleRad);



                // Lap joint step visualization - showing where shell becomes half thickness
                const lapEndAngle = angle - lapAngleDeg;
                const lapEndRad = (lapEndAngle * Math.PI) / 180;
                
                const lapEndMidX = topCx + midRadius * Math.cos(lapEndRad);
                const lapEndMidY = topCy + midRadius * Math.sin(lapEndRad);
                const lapEndInnerX = topCx + innerRadius * Math.cos(lapEndRad);
                const lapEndInnerY = topCy + innerRadius * Math.sin(lapEndRad);
                
                // Half-thickness cut line (from outer to mid at the boundary)
                topCutLines += `<line x1="${outerX}" y1="${outerY}" x2="${midX}" y2="${midY}" stroke="#3889fb" stroke-width=".5"/>`;
                // Arc at midRadius showing the step edge
                topCutLines += `<path d="M${midX},${midY} A${midRadius},${midRadius} 0 0,0 ${lapEndMidX},${lapEndMidY}" fill="none" stroke="#3889fb" stroke-width=".5"/>`;
                // Radial line at lap end (from mid to inner)
                topCutLines += `<line x1="${lapEndMidX}" y1="${lapEndMidY}" x2="${lapEndInnerX}" y2="${lapEndInnerY}" stroke="#3889fb" stroke-width=".5"/>`;
            }

            // Lug positions - ensure minimum spacing of lug hole diameter
            const minLugSpacingPx = lugR * 2; // Minimum visual spacing = lug diameter
            const lugTopPx = Math.min(lugTop * scale, sideHeight - minLugSpacingPx - lugR);
            const rawLugBottomPx = lugTopPx + lugSpace * scale;
            const lugBottomPx = Math.max(rawLugBottomPx, lugTopPx + minLugSpacingPx);

            return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}">
  <rect width="100%" height="100%" fill="#fff"/>
  
  <!-- TOP VIEW -->
  <text x="${topCx}" y="30" font-family="Arial, sans-serif" font-size="11" font-weight="bold" text-anchor="middle">TOP VIEW</text>
  ${topPieSlices}
  <circle cx="${topCx}" cy="${topCy}" r="${topRadius}" fill="none" stroke="#000" stroke-width="1"/>
  <circle cx="${topCx}" cy="${topCy}" r="${innerRadius}" fill="none" stroke="#000" stroke-width="1"/>
  ${topCutLines}
  <text x="${topCx}" y="${topCy - 8}" font-family="Arial, sans-serif" font-size="7" text-anchor="middle">${segments} Pieces</text>
  <text x="${topCx}" y="${topCy}" font-family="Arial, sans-serif" font-size="7" text-anchor="middle">${lapPct}% Overlap</text>
  <text x="${topCx}" y="${topCy + 8}" font-family="Arial, sans-serif" font-size="7" text-anchor="middle">${thickMm}mm Shell</text>
  <line x1="${topCx - topRadius}" y1="${topCy + topRadius + 15}" x2="${topCx + topRadius}" y2="${topCy + topRadius + 15}" stroke="#3889fb" stroke-width=".5" marker-start="url(#arrow)" marker-end="url(#arrow)"/>
  <text x="${topCx}" y="${topCy + topRadius + 28}" font-family="Arial, sans-serif" font-size="10" text-anchor="middle">‚åÄ${diam}"</text>
  
  <line x1="20" y1="${sideY - 40}" x2="${svgWidth - 20}" y2="${sideY - 40}" stroke="#e2e2e2" stroke-width="1"/>
  
  <!-- SIDE VIEW -->
  <text x="${sideX + sideWidth / 2}" y="${sideY - 18}" font-family="Arial, sans-serif" font-size="11" font-weight="bold" text-anchor="middle">SIDE VIEW</text>
  <line x1="${sideX}" y1="${sideY}" x2="${sideX + sideWidth}" y2="${sideY}" stroke="#000" stroke-width="1"/>
  <line x1="${sideX}" y1="${sideY + sideHeight}" x2="${sideX + sideWidth}" y2="${sideY + sideHeight}" stroke="#000" stroke-width="1"/>
  <line x1="${sideX}" y1="${sideY}" x2="${sideX}" y2="${sideY + sideHeight}" stroke="#3889fb" stroke-width="1"/>
  <line x1="${sideX + visualThickPx}" y1="${sideY}" x2="${sideX + visualThickPx}" y2="${sideY + sideHeight}" stroke="#3889fb" stroke-width="1"/>
  <line x1="${sideX + sideWidth}" y1="${sideY}" x2="${sideX + sideWidth}" y2="${sideY + sideHeight}" stroke="#000" stroke-width="1"/>
  <line x1="${sideX + sideWidth - visualThickPx}" y1="${sideY}" x2="${sideX + sideWidth - visualThickPx}" y2="${sideY + sideHeight}" stroke="#000" stroke-width="1"/>
  <line x1="${sideX}" y1="${sideY + sideHeight + 8}" x2="${sideX + visualThickPx}" y2="${sideY + sideHeight + 8}" stroke="#3889fb" stroke-width=".5"/>
  <line x1="${sideX}" y1="${sideY + sideHeight + 5}" x2="${sideX}" y2="${sideY + sideHeight + 11}" stroke="#3889fb" stroke-width=".5"/>
  <line x1="${sideX + visualThickPx}" y1="${sideY + sideHeight + 5}" x2="${sideX + visualThickPx}" y2="${sideY + sideHeight + 11}" stroke="#3889fb" stroke-width=".5"/>
  <text x="${(sideX + sideX + visualThickPx) / 2}" y="${sideY + sideHeight + 18}" font-family="Arial, sans-serif" font-size="7" text-anchor="middle">${thickMm}mm Shell Thickness</text>
  <circle cx="${sideX + 15}" cy="${sideY + lugTopPx}" r="${lugR}" fill="none" stroke="#000" stroke-width="1"/>
  <circle cx="${sideX + 15}" cy="${sideY + lugBottomPx}" r="${lugR}" fill="none" stroke="#000" stroke-width="1"/>
  <circle cx="${sideX + sideWidth - 15}" cy="${sideY + lugTopPx}" r="${lugR}" fill="none" stroke="#000" stroke-width="1"/>
  <circle cx="${sideX + sideWidth - 15}" cy="${sideY + lugBottomPx}" r="${lugR}" fill="none" stroke="#000" stroke-width="1"/>
  <line x1="${sideX + sideWidth - 15 - lugR}" y1="${sideY + lugBottomPx}" x2="${sideX + sideWidth - 15 + lugR}" y2="${sideY + lugBottomPx}" stroke="#3889fb" stroke-width="1" marker-start="url(#smallArrow)" marker-end="url(#smallArrow)"/>
  <text x="${sideX + sideWidth - 15}" y="${sideY + lugBottomPx + lugR + 5}" font-family="Arial, sans-serif" font-size="4" text-anchor="middle">‚åÄ${lugDiam}"</text>
  <line x1="${sideX + sideWidth + 12}" y1="${sideY}" x2="${sideX + sideWidth + 12}" y2="${sideY + sideHeight}" stroke="#3889fb" stroke-width=".5" marker-start="url(#arrow)" marker-end="url(#arrow)"/>
  <text x="${sideX + sideWidth + 16}" y="${sideY + sideHeight / 2}" font-family="Arial, sans-serif" font-size="9" dominant-baseline="middle">${height}"</text>
  <line x1="${sideX - 18}" y1="${sideY}" x2="${sideX - 18}" y2="${sideY + lugTopPx}" stroke="#3889fb" stroke-width=".5"/>
  <line x1="${sideX - 22}" y1="${sideY}" x2="${sideX - 14}" y2="${sideY}" stroke="#3889fb" stroke-width=".5"/>
  <line x1="${sideX - 25}" y1="${sideY + lugTopPx}" x2="${sideX - 11}" y2="${sideY + lugTopPx}" stroke="#3889fb" stroke-width=".5"/>
  <text x="${sideX - 28}" y="${sideY + lugTopPx / 2}" font-family="Arial, sans-serif" font-size="8" text-anchor="end" dominant-baseline="middle">${lugTop}"</text>
  <line x1="${sideX - 18}" y1="${sideY + lugTopPx}" x2="${sideX - 18}" y2="${sideY + lugBottomPx}" stroke="#3889fb" stroke-width=".5"/>
  <line x1="${sideX - 22}" y1="${sideY + lugBottomPx}" x2="${sideX - 14}" y2="${sideY + lugBottomPx}" stroke="#3889fb" stroke-width=".5"/>
  <text x="${sideX - 28}" y="${sideY + (lugTopPx + lugBottomPx) / 2}" font-family="Arial, sans-serif" font-size="8" text-anchor="end" dominant-baseline="middle">${lugSpace}"</text>
  
  <line x1="20" y1="${platformCy - topRadius - 40}" x2="${svgWidth - 20}" y2="${platformCy - topRadius - 40}" stroke="#e2e2e2" stroke-width="1"/>
  
  <!-- PIEZO SENSOR PLATFORM -->
  <text x="${platformCx}" y="${platformCy - topRadius - 18}" font-family="Arial, sans-serif" font-size="11" font-weight="bold" text-anchor="middle">PIEZO SENSOR PLATFORM</text>
  <circle cx="${platformCx}" cy="${platformCy}" r="${platformOuterRadius}" fill="none" stroke="#ccc" stroke-width="1" stroke-dasharray="4,4"/>
  <circle cx="${platformCx}" cy="${platformCy}" r="${centerCircleRadiusPx}" fill="#f5f5f5" stroke="#000" stroke-width="1"/>
  <path d="${platformPath}" fill="#e8f4ff" stroke="#000" stroke-width="1"/>
  ${outputHoleEnabled ? `<circle cx="${platformCx}" cy="${platformCy - (centerCircleRadiusPx + platformOuterRadius) / 2}" r="${(outputHoleDiam * scale) / 2}" fill="#fff" stroke="#000" stroke-width="1"/>` : ''}
  <text x="${platformCx}" y="${platformCy + centerCircleRadiusPx + 12}" font-family="Arial, sans-serif" font-size="8" text-anchor="middle">${centerCircleMm}mm</text>
  
  <defs>
    <marker id="arrow" markerWidth="6" markerHeight="6" refX="3" refY="3" orient="auto-start-reverse">
      <path d="M0,0 L6,3 L0,6 Z" fill="#3889fb"/>
    </marker>
    <marker id="smallArrow" markerWidth="4" markerHeight="4" refX="2" refY="2" orient="auto-start-reverse">
      <path d="M0,0 L4,2 L0,4 Z" fill="#3889fb"/>
    </marker>
  </defs>
</svg>`;
        }

        function updateLivePreview() {
            const previewFrame = document.getElementById('previewFrame');
            const previewImage = document.getElementById('previewImage');
            const previewEmpty = document.getElementById('previewEmpty');

            try {
                const parameters = getParameters();
                const svgText = buildPreviewSvg(parameters);
                previewImage.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
                previewFrame.classList.add('has-image');
                previewEmpty.style.display = 'none';
            } catch (error) {
                console.error('Error generating preview:', error);
                previewEmpty.textContent = 'Preview unavailable.';
                previewEmpty.style.display = 'block';
                previewFrame.classList.remove('has-image');
            }
        }

        function debouncedUpdatePreview() {
            // Immediate update since SVG generation is client-side
            updateLivePreview();
        }

        // Get current parameter values as numbers
        function getCurrentValues() {
            const values = {};
            for (const key of Object.keys(config.parameters)) {
                const input = document.getElementById(key);
                if (input) {
                    values[key] = parseFloat(input.value) || 0;
                }
            }
            return values;
        }

        // Calculate dynamic max constraints
        function getDynamicMax(key, values) {
            const param = config.parameters[key];
            if (!param) return null;
            
            // Dynamic constraints for lug positioning
            if (key === 'LugTopDist') {
                // Top hole center must allow: top hole radius fits, and bottom hole fits with 0.5" margin
                // LugTopDist + LugSpacing + LugHoleDiam/2 + 0.5 <= ShellHeight
                // So LugTopDist <= ShellHeight - LugSpacing - LugHoleDiam/2 - 0.5
                const maxVal = values.ShellHeight - values.LugSpacing - (values.LugHoleDiam / 2) - 0.5;
                return Math.max(0.5, maxVal);
            }
            
            if (key === 'LugSpacing') {
                // LugTopDist + LugSpacing + LugHoleDiam/2 + 0.5 <= ShellHeight
                // So LugSpacing <= ShellHeight - LugTopDist - LugHoleDiam/2 - 0.5
                const maxVal = values.ShellHeight - values.LugTopDist - (values.LugHoleDiam / 2) - 0.5;
                return Math.max(0.5, maxVal);
            }
            
            return param.max;
        }

        // Update dynamic slider max values based on current parameter values
        function updateDynamicSliders(changedKey) {
            // Only update if a relevant parameter changed
            const relevantParams = ['ShellHeight', 'LugTopDist', 'LugSpacing', 'LugHoleDiam'];
            if (changedKey && !relevantParams.includes(changedKey)) {
                return; // No need to update dynamic sliders
            }
            
            const values = getCurrentValues();
            
            // Update all sliders with dynamic max
            document.querySelectorAll('.dynamic-slider').forEach(slider => {
                const key = slider.dataset.param;
                // Don't adjust the slider that the user is currently dragging
                if (key === changedKey) return;
                
                if (key && config.parameters[key]) {
                    const newMax = getDynamicMax(key, values);
                    if (newMax === null) return;
                    
                    const currentValue = parseFloat(slider.value);
                    const currentMax = parseFloat(slider.max);
                    
                    // Update the range text display (always, so user sees valid range)
                    const param = config.parameters[key];
                    const unit = param.unit || '';
                    const rangeSpan = document.querySelector(`#${key}`)?.closest('.parameter-group')?.querySelector('.dynamic-range');
                    if (rangeSpan) {
                        rangeSpan.textContent = `${param.min}‚Äì${newMax.toFixed(1)}${unit ? ' ' + unit : ''}`;
                    }
                    
                    // Only update slider max if it actually changed
                    if (Math.abs(currentMax - newMax) > 0.001) {
                        slider.max = newMax;
                    }
                    
                    // Only clamp value if it exceeds the new constraint
                    if (currentValue > newMax) {
                        slider.value = newMax;
                        const input = document.getElementById(key);
                        if (input) input.value = newMax.toFixed(2);
                        debouncedUpdatePreview();
                    }
                }
            });
        }

        // Validate all parameters
        function validateParameters() {
            const values = getCurrentValues();
            const errors = {};
            let isValid = true;

            for (const [key, param] of Object.entries(config.parameters)) {
                const value = values[key];
                const min = param.min;
                const max = getDynamicMax(key, values) ?? param.max;
                
                let error = null;
                
                if (isNaN(value) || value === '') {
                    error = 'Please enter a valid number';
                } else if (min !== null && min !== undefined && value < min) {
                    const unit = param.unit || '';
                    error = `Minimum is ${min}${unit ? ' ' + unit : ''}`;
                } else if (max !== null && max !== undefined && value > max) {
                    const unit = param.unit || '';
                    error = `Maximum is ${max.toFixed(2)}${unit ? ' ' + unit : ''}`;
                }
                
                // Update UI for this parameter
                const group = document.getElementById(key)?.closest('.parameter-group');
                const errorDiv = group?.querySelector('.parameter-error');
                const rangeSpan = group?.querySelector('.dynamic-range');
                
                // Update dynamic range display
                if (rangeSpan && param.dynamicMax) {
                    const unit = param.unit || '';
                    rangeSpan.textContent = `${param.min}‚Äì${max.toFixed(1)}${unit ? ' ' + unit : ''}`;
                }
                
                if (error) {
                    errors[key] = error;
                    isValid = false;
                    group?.classList.add('invalid');
                    if (errorDiv) errorDiv.textContent = error;
                } else {
                    group?.classList.remove('invalid');
                }
            }
            
            // Update validation summary and submit button
            const validationSummary = document.getElementById('validationSummary');
            const submitBtn = document.getElementById('submitBtn');
            
            if (isValid) {
                validationSummary?.classList.remove('show');
                submitBtn.disabled = false;
            } else {
                validationSummary?.classList.add('show');
                submitBtn.disabled = true;
            }
            
            return isValid;
        }

        function renderParameters() {
            const grid = document.getElementById('parametersGrid');
            grid.innerHTML = '';

            for (const [key, param] of Object.entries(config.parameters)) {
                const group = document.createElement('div');
                group.className = 'parameter-group';
                const label = param.label || key;
                const description = param.description || '';
                
                // Determine input type and formatting based on parameter type
                const isNumeric = param.type === 'number' || param.type === 'dimension';
                const unitSuffix = param.unit ? `<span class="unit-suffix">${param.unit}</span>` : '';
                const defaultDisplay = param.unit ? `${param.default} ${param.unit}` : param.default;
                
                // Build range note
                let rangeNote = '';
                if (param.min !== null && param.min !== undefined && param.max !== null && param.max !== undefined) {
                    const unit = param.unit || '';
                    rangeNote = ` (${param.min}‚Äì${param.max}${unit ? ' ' + unit : ''})`;
                } else if (param.min !== null && param.min !== undefined) {
                    const unit = param.unit || '';
                    rangeNote = ` (min: ${param.min}${unit ? ' ' + unit : ''})`;
                } else if (param.max !== null && param.max !== undefined) {
                    const unit = param.unit || '';
                    rangeNote = ` (max: ${param.max}${unit ? ' ' + unit : ''})`;
                }
                // For dynamic constraints, calculate initial max and show it
                if (param.dynamicMax) {
                    const unit = param.unit || '';
                    // Calculate initial max using defaults
                    const defaults = {};
                    for (const [k, p] of Object.entries(config.parameters)) {
                        defaults[k] = p.default;
                    }
                    const initialMax = getDynamicMax(key, defaults);
                    rangeNote = ` (<span class="dynamic-range">${param.min}‚Äì${initialMax.toFixed(1)}${unit ? ' ' + unit : ''}</span>)`;
                }
                
                // Special layout for optional/toggleable parameters (spans 2 columns)
                if (param.toggleable) {
                    group.className = 'parameter-group optional-param';
                    const hasSlider = param.min != null && param.max != null;
                    group.innerHTML = `
                        <div class="optional-content">
                            <label class="optional-toggle">
                                <input type="checkbox" id="${key}_enabled" checked>
                                <span class="optional-label">Include hole for ${label.toLowerCase()}</span>
                            </label>
                            <div class="optional-input-row" id="${key}_inputRow">
                                <span class="optional-input-label">Hole diameter:</span>
                                <div class="input-with-unit">
                                    <input 
                                        type="text"
                                        inputmode="decimal"
                                        id="${key}" 
                                        value="${param.default}"
                                        placeholder="${param.default}"
                                    >
                                    ${unitSuffix}
                                </div>
                                ${hasSlider ? `
                                <input 
                                    type="range" 
                                    class="parameter-slider"
                                    id="${key}_slider"
                                    min="${param.min}"
                                    max="${param.max}"
                                    step="0.0625"
                                    value="${param.default}"
                                >` : ''}
                                <span class="optional-range">${rangeNote.replace(' (', '(')}</span>
                            </div>
                        </div>
                        <div class="parameter-error"></div>
                    `;
                    grid.appendChild(group);
                    
                    const checkbox = group.querySelector(`#${key}_enabled`);
                    const inputRow = group.querySelector(`#${key}_inputRow`);
                    const input = group.querySelector(`#${key}`);
                    const slider = group.querySelector(`#${key}_slider`);
                    
                    checkbox.addEventListener('change', () => {
                        inputRow.classList.toggle('hidden', !checkbox.checked);
                        debouncedUpdatePreview();
                    });
                    
                    // Sync slider to input
                    if (slider) {
                        slider.addEventListener('input', (e) => {
                            input.value = e.target.value;
                            debouncedUpdatePreview();
                            validateParameters();
                        });
                    }
                    
                    input.addEventListener('input', (e) => {
                        const cleaned = e.target.value.replace(/[^0-9.\-]/g, '')
                            .replace(/(?!^)-/g, '')
                            .replace(/(\..*)\./g, '$1');
                        if (cleaned !== e.target.value) {
                            e.target.value = cleaned;
                        }
                        // Sync input to slider
                        if (slider && !isNaN(parseFloat(cleaned))) {
                            const val = parseFloat(cleaned);
                            const min = parseFloat(slider.min);
                            const max = parseFloat(slider.max);
                            slider.value = Math.min(max, Math.max(min, val));
                        }
                        debouncedUpdatePreview();
                        validateParameters();
                    });
                    
                    input.addEventListener('change', () => {
                        debouncedUpdatePreview();
                        validateParameters();
                    });
                    continue;
                }
                
                group.innerHTML = `
                    <label data-description="${description}">${label}<span class="label-tooltip">${description}</span></label>
                    <div class="input-with-slider">
                        <div class="input-with-unit">
                            <input 
                                type="text"
                                inputmode="${isNumeric ? 'decimal' : 'text'}"
                                id="${key}" 
                                value="${param.default}"
                                placeholder="${param.default}"
                            >
                            ${unitSuffix}
                        </div>
                        ${isNumeric && param.min != null && (param.max != null || param.dynamicMax) ? (() => {
                            // Calculate slider max - use dynamic max if applicable
                            let sliderMax = param.max;
                            if (param.dynamicMax) {
                                const defaults = {};
                                for (const [k, p] of Object.entries(config.parameters)) {
                                    defaults[k] = p.default;
                                }
                                sliderMax = getDynamicMax(key, defaults);
                            }
                            return `
                        <input 
                            type="range" 
                            class="parameter-slider${param.dynamicMax ? ' dynamic-slider' : ''}"
                            id="${key}_slider"
                            data-param="${key}"
                            min="${param.min}"
                            max="${sliderMax}"
                            step="${param.type === 'number' ? 1 : 0.125}"
                            value="${param.default}"
                        >`;
                        })() : ''}
                    </div>
                    <div class="parameter-note">Default: ${defaultDisplay}${rangeNote}</div>
                    <div class="parameter-error"></div>
                `;
                grid.appendChild(group);

                // Add live preview update on input change
                const input = group.querySelector('input[type="text"]');
                const slider = group.querySelector(`#${key}_slider`);
                
                // Sync slider and input
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        input.value = e.target.value;
                        debouncedUpdatePreview();
                        validateParameters();
                        updateDynamicSliders(key);
                    });
                }
                
                // For number/dimension inputs, strip any non-numeric characters
                if (param.type === 'number' || param.type === 'dimension') {
                    input.addEventListener('input', (e) => {
                        // Allow only digits, decimal point, and minus sign at start
                        const cleaned = e.target.value.replace(/[^0-9.\-]/g, '')
                            .replace(/(?!^)-/g, '')  // minus only at start
                            .replace(/(\..*)\./g, '$1');  // only one decimal
                        if (cleaned !== e.target.value) {
                            e.target.value = cleaned;
                        }                        // Update slider if present
                        if (slider && !isNaN(parseFloat(cleaned))) {
                            const val = parseFloat(cleaned);
                            const min = parseFloat(slider.min);
                            const max = parseFloat(slider.max);
                            slider.value = Math.min(max, Math.max(min, val));
                        }                    });
                }
                
                input.addEventListener('input', () => {
                    debouncedUpdatePreview();
                    validateParameters();
                    updateDynamicSliders(key);
                });
                input.addEventListener('change', () => {
                    debouncedUpdatePreview();
                    validateParameters();
                    updateDynamicSliders(key);
                });
                
                // Label click to show tooltip
                const labelEl = group.querySelector('label[data-description]');
                const tooltip = group.querySelector('.label-tooltip');
                if (labelEl && tooltip) {
                    labelEl.addEventListener('click', (e) => {
                        e.preventDefault();
                        // Hide all other tooltips first
                        document.querySelectorAll('.label-tooltip.show').forEach(t => {
                            if (t !== tooltip) t.classList.remove('show');
                        });
                        tooltip.classList.toggle('show');
                    });
                }
            }
            
            // Close tooltips when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('label')) {
                    document.querySelectorAll('.label-tooltip.show').forEach(t => {
                        t.classList.remove('show');
                    });
                }
            });
            
            // Initial validation
            validateParameters();
            // Initialize dynamic slider ranges
            updateDynamicSliders();
        }

        function setupEventListeners() {
            const submitBtn = document.getElementById('submitBtn');
            const resetBtn = document.getElementById('resetBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const previewImage = document.getElementById('previewImage');
            const previewFrame = document.getElementById('previewFrame');
            const previewEmpty = document.getElementById('previewEmpty');

            previewImage.addEventListener('load', () => {
                previewFrame.classList.add('has-image');
                previewEmpty.style.display = 'none';
            });

            previewImage.addEventListener('error', () => {
                previewFrame.classList.remove('has-image');
                previewEmpty.style.display = 'block';
            });

            // Submit handling
            submitBtn.addEventListener('click', handleSubmit);
            resetBtn.addEventListener('click', handleReset);
            downloadBtn.addEventListener('click', handleDownload);
        }

        async function handleSubmit() {
            const parameters = getParameters();

            console.log('üì§ Sending parameters:', JSON.stringify(parameters, null, 2));
            
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.classList.add('loading');
            document.getElementById('downloadSection').style.display = 'none';

            try {
                showStatus('Submitting to Autodesk...', 'pending', true);

                const response = await fetch('/api/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parameters })
                });

                if (!response.ok) {
                    throw new Error(`Submission failed: ${response.statusText}`);
                }

                const data = await response.json();
                currentJobId = data.workItemId;

                showStatus(
                    `‚úì Job submitted! ID: <div class="status-id">${currentJobId}</div>
                    Processing... (this may take 2-5 minutes)`,
                    'pending',
                    true
                );

                // Poll for status
                pollJobStatus();
            } catch (error) {
                console.error('Error submitting job:', error);
                showStatus(`Submission error: ${error.message}`, 'error');
                submitBtn.disabled = false;
                submitBtn.classList.remove('loading');
            }
        }

        async function pollJobStatus() {
            if (!currentJobId) return;

            try {
                const response = await fetch(`/api/job-status/${currentJobId}`);
                if (!response.ok) throw new Error('Failed to get status');

                const data = await response.json();

                // Update progress bar if available
                if (data.progress !== undefined) {
                    const progressFill = document.querySelector('.progress-fill');
                    if (progressFill) {
                        progressFill.style.width = `${data.progress}%`;
                    }
                }

                if (data.status === 'success') {
                    showStatus(
                        '‚úì Processing complete! Your modified drum parameters have been applied.',
                        'success'
                    );
                    document.getElementById('submitBtn').disabled = false;
                    document.getElementById('submitBtn').classList.remove('loading');
                    document.getElementById('downloadSection').style.display = 'block';
                    showPreview(currentJobId);
                } else if (data.status === 'failed' || data.status === 'cancelled') {
                    showStatus(`‚úó Job ${data.status}. Please try again.`, 'error');
                    document.getElementById('submitBtn').disabled = false;
                    document.getElementById('submitBtn').classList.remove('loading');
                    clearPreviewRefresh();
                } else {
                    // Still pending - update status message
                    const progressPercent = data.progress !== undefined ? ` ${data.progress}%` : '';
                    showStatus(
                        `‚è≥ Processing...${progressPercent}<br><small>Job ID: ${currentJobId}</small>`,
                        'pending',
                        true
                    );
                    // Check again in 1 second
                    setTimeout(pollJobStatus, 1000);
                }
            } catch (error) {
                console.error('Error polling status:', error);
                // Continue polling on error
                setTimeout(pollJobStatus, 2000);
            }
        }

        function handleReset() {
            currentJobId = null;
            document.getElementById('submitBtn').disabled = false;
            document.getElementById('submitBtn').classList.remove('loading');
            document.getElementById('status').classList.remove('show');
            document.getElementById('downloadSection').style.display = 'none';
            if (previewObjectUrl) {
                URL.revokeObjectURL(previewObjectUrl);
                previewObjectUrl = null;
            }
            document.getElementById('previewLink').setAttribute('href', '#');
            document.getElementById('previewLink').style.display = 'none';
            clearPreviewRefresh();
            renderParameters();
            // Refresh live preview with default values
            updateLivePreview();
        }

        function clearPreviewRefresh() {
            if (previewRefreshTimer) {
                clearInterval(previewRefreshTimer);
                previewRefreshTimer = null;
            }
        }

        async function updatePreviewImage(baseUrl) {
            if (previewRequestInFlight) return;
            previewRequestInFlight = true;

            const previewFrame = document.getElementById('previewFrame');
            const previewImage = document.getElementById('previewImage');
            const previewEmpty = document.getElementById('previewEmpty');

            try {
                const response = await fetch(`${baseUrl}?t=${Date.now()}`, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Preview fetch failed: ${response.status}`);
                }

                const contentType = response.headers.get('content-type') || '';
                const blob = await response.blob();

                if (previewObjectUrl) {
                    URL.revokeObjectURL(previewObjectUrl);
                }

                previewObjectUrl = URL.createObjectURL(blob);
                previewImage.src = previewObjectUrl;
                previewImage.dataset.contentType = contentType;
                previewFrame.classList.add('has-image');
                previewEmpty.style.display = 'none';

                if (!contentType.includes('svg')) {
                    clearPreviewRefresh();
                }
            } catch (error) {
                console.error('Error fetching preview:', error);
            } finally {
                previewRequestInFlight = false;
            }
        }

        function showPreview(jobId) {
            const previewLink = document.getElementById('previewLink');
            const baseUrl = `/api/preview/${jobId}`;

            previewLink.href = `${baseUrl}?full=1`;
            previewLink.style.display = 'inline';

            clearPreviewRefresh();
            // Refresh the preview from the job endpoint
            updatePreviewImage(baseUrl);
        }

        async function handleDownload() {
            if (!currentJobId) {
                showStatus('No job ID available for download', 'error');
                return;
            }

            try {
                const downloadBtn = document.getElementById('downloadBtn');
                downloadBtn.disabled = true;
                downloadBtn.classList.add('loading');
                downloadBtn.textContent = '‚¨áÔ∏è Downloading...'

                const response = await fetch(`/api/download/${currentJobId}`);
                if (!response.ok) {
                    throw new Error(`Download failed: ${response.statusText}`);
                }

                // Get filename from response header or use default
                const contentDisposition = response.headers.get('content-disposition');
                let filename = 'modified_drum.stl';
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                    if (filenameMatch) filename = filenameMatch[1];
                }

                // Convert response to blob and trigger download
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);

                downloadBtn.disabled = false;
                downloadBtn.classList.remove('loading');
                downloadBtn.textContent = '‚¨áÔ∏è Download Modified Drum File';
            } catch (error) {
                console.error('Error downloading file:', error);
                showStatus(`Download error: ${error.message}`, 'error');
                const downloadBtn = document.getElementById('downloadBtn');
                downloadBtn.disabled = false;
                downloadBtn.classList.remove('loading');
                downloadBtn.textContent = '‚¨áÔ∏è Download Modified Drum File';
            }
        }

        function showStatus(message, type, showProgress = false) {
            const status = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            const progress = document.getElementById('progress');

            status.className = `status show ${type}`;
            statusText.innerHTML = message;
            progress.style.display = showProgress ? 'block' : 'none';
        }

        // Auto-reload when server restarts (dev mode only)
        // Requires multiple consecutive failures to avoid false positives during navigation
        let serverDownCount = 0;
        const REQUIRED_DOWN_COUNT = 3; // Must fail 3 times in a row (1.5 seconds)
        
        setInterval(async () => {
            // Don't poll when page is hidden (user navigated away)
            if (document.hidden) {
                serverDownCount = 0;
                return;
            }
            
            try {
                const response = await fetch('/api/health');
                if (response.ok) {
                    if (serverDownCount >= REQUIRED_DOWN_COUNT) {
                        console.log('Server is back online, reloading page...');
                        window.location.reload();
                    }
                    serverDownCount = 0;
                } else {
                    serverDownCount++;
                }
            } catch (error) {
                serverDownCount++;
            }
        }, 500); // Check every 500ms

        // Fade in page once loaded to avoid layout shift flash
        window.addEventListener('load', () => {
            document.body.classList.add('loaded');
        });
        // Fallback in case load event already fired
        if (document.readyState === 'complete') {
            document.body.classList.add('loaded');
        }

        // Lightbox functionality for gallery images
        (function() {
            const modal = document.getElementById('lightboxModal');
            const modalImg = document.getElementById('lightboxImage');
            const modalCaption = document.getElementById('lightboxCaption');
            const closeBtn = modal.querySelector('.lightbox-close');

            // Add click handlers to gallery images
            document.querySelectorAll('.gallery-item img').forEach(img => {
                img.addEventListener('click', function() {
                    const caption = this.closest('.gallery-item').querySelector('.gallery-caption');
                    modalImg.src = this.src;
                    modalImg.alt = this.alt;
                    if (caption) {
                        modalCaption.innerHTML = caption.innerHTML;
                    } else {
                        modalCaption.innerHTML = '';
                    }
                    modal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                });
            });

            // Close modal on X click
            closeBtn.addEventListener('click', closeLightbox);

            // Close modal on backdrop click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeLightbox();
                }
            });

            // Close modal on Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal.classList.contains('active')) {
                    closeLightbox();
                }
            });

            function closeLightbox() {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        })();
    </script>
</body>
</html>
