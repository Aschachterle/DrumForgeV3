<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/images/logo.png">
    <link rel="stylesheet" href="/css/common.css">
    <link rel="stylesheet" href="/css/drum.css">
    <title>Parametric Drum - Extrudo</title>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="/" class="back-link">
                ‚Üê Back to Models
            </a>
            <img class="header-logo" src="/images/logo.png" alt="Extrudo logo">
        </div>

        <div class="layout">
            <div class="panel">
                <div class="panel-header">Configuration</div>
                <p class="description">Welcome to the Extrudo E-Drum modeler. I built this tool as a proof of concept using Fusion 360's API and Autodesk's Design Automation service. You can modify the drum parameters below to create a custom 3d printable E-drum shell along with a matching sensor platform. Once you are happy with your drum size, lug spacing, and other parameters, you can generate the final STL file for 3D printing. Currently I only have a developer license so once my API usage limits are reached it may stop processing requests until the limit resets.</p>

                <!-- Parameters Section -->
                <div class="section">
                    <div class="section-title">
                        <div class="section-icon">1</div>
                        Modify Parameters
                    </div>
                    <div class="parameters-grid" id="parametersGrid">
                        <!-- Will be filled by JavaScript -->
                    </div>
                </div>

                <!-- Submit Section -->
                <div class="section">
                    <div class="section-title">
                        <div class="section-icon">2</div>
                        Process Your Drum
                    </div>
                    <div class="validation-summary" id="validationSummary">
                        Please fix the highlighted parameters before generating.
                    </div>
                    <div class="button-group">
                        <button class="btn-submit" id="submitBtn">
                            Generate Modified Drum
                        </button>
                        <button class="btn-secondary" id="resetBtn">Reset Parameters</button>
                    </div>
                </div>

                <!-- Status Section -->
                <div class="status" id="status">
                    <div class="status-text" id="statusText"></div>
                    <div class="progress" id="progress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                    </div>
                    <div id="statusDetails"></div>
                    <div id="downloadSection" style="display: none; margin-top: 15px;">
                        <button class="btn-submit" id="downloadBtn" style="width: 100%;">
                            Download Modified Drum File
                        </button>
                    </div>
                </div>

            </div>

            <div class="panel">
                <div class="panel-header">Preview</div>
                <div class="preview-frame" id="previewFrame">
                    <div class="preview-empty" id="previewEmpty">Loading preview...</div>
                    <img id="previewImage" alt="Modified drum preview">
                </div>
                <div class="preview-actions">
                    <span>Preview updates as you adjust parameters.</span>
                    <a id="previewLink" class="preview-link" href="#" target="_blank" rel="noopener" style="display:none;">Open full size</a>
                </div>
            </div>
        </div>

        <!-- Example Gallery Section -->
        <div class="gallery-section">
            <div class="gallery-header">
                <h2>What You'll Get</h2>
                <p>See examples of generated drum shells and what they look like printed.</p>
            </div>
            <div class="gallery-grid">
                <div class="gallery-item">
                    <img src="/images/gallery/fusion-preview.png" alt="Fusion 360 model preview">
                    <div class="gallery-caption">
                        <strong>STL Output Example</strong>
                        <span>The STL file ready for 3D printing</span>
                    </div>
                </div>
                <div class="gallery-item">
                    <img src="/images/gallery/printed-drum.png" alt="Fusion 360 model preview">
                    <div class="gallery-caption">
                        <strong>Printed and Assembled Example</strong>
                        <span>A 3D printed and assembled drum shell</span>
                    </div>
                </div>
                <!-- Future gallery items for 3D printed examples -->
                <!--
                <div class="gallery-item">
                    <img src="/images/gallery/print-example-1.jpg" alt="3D printed drum shell">
                    <div class="gallery-caption">
                        <strong>3D Printed Shell</strong>
                        <span>PLA, 0.2mm layer height</span>
                    </div>
                </div>
                -->
            </div>
        </div>
    </div>

    <script>
        let config = {};
        let currentJobId = null;
        let previewRefreshTimer = null;
        let previewObjectUrl = null;
        let previewRequestInFlight = false;
        let livePreviewDebounce = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await loadConfig();
            setupEventListeners();
            // Show live preview immediately
            updateLivePreview();
        });

        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                config = await response.json();
                renderParameters();
            } catch (error) {
                console.error('Error loading config:', error);
                showStatus('Error loading configuration', 'error');
            }
        }

        function getParameters() {
            const parameters = {};
            for (const [key, param] of Object.entries(config.parameters)) {
                const input = document.getElementById(key);
                if (input) {
                    let value = input.value;
                    if (param.type === 'number') {
                        value = parseFloat(value);
                    } else if (param.type === 'dimension') {
                        // Append unit to numeric value for dimension fields
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            value = `${numValue} ${param.unit}`;
                        }
                    }
                    parameters[key] = value;
                }
            }
            return parameters;
        }

        async function updateLivePreview() {
            if (previewRequestInFlight) return;
            previewRequestInFlight = true;

            const previewFrame = document.getElementById('previewFrame');
            const previewImage = document.getElementById('previewImage');
            const previewEmpty = document.getElementById('previewEmpty');

            try {
                const parameters = getParameters();
                const response = await fetch('/api/preview-svg', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parameters })
                });

                if (!response.ok) {
                    throw new Error(`Preview fetch failed: ${response.status}`);
                }

                const blob = await response.blob();
                if (previewObjectUrl) {
                    URL.revokeObjectURL(previewObjectUrl);
                }
                previewObjectUrl = URL.createObjectURL(blob);
                previewImage.src = previewObjectUrl;
                previewFrame.classList.add('has-image');
                previewEmpty.style.display = 'none';
            } catch (error) {
                console.error('Error fetching live preview:', error);
                previewEmpty.textContent = 'Preview unavailable.';
                previewEmpty.style.display = 'block';
                previewFrame.classList.remove('has-image');
            } finally {
                previewRequestInFlight = false;
            }
        }

        function debouncedUpdatePreview() {
            if (livePreviewDebounce) {
                clearTimeout(livePreviewDebounce);
            }
            livePreviewDebounce = setTimeout(updateLivePreview, 150);
        }

        // Get current parameter values as numbers
        function getCurrentValues() {
            const values = {};
            for (const key of Object.keys(config.parameters)) {
                const input = document.getElementById(key);
                if (input) {
                    values[key] = parseFloat(input.value) || 0;
                }
            }
            return values;
        }

        // Calculate dynamic max constraints
        function getDynamicMax(key, values) {
            const param = config.parameters[key];
            if (!param) return null;
            
            // Dynamic constraints for lug positioning
            if (key === 'LugTopDist') {
                // Top hole center must allow: top hole radius fits, and bottom hole fits
                // LugTopDist + LugSpacing + LugHoleDiam/2 <= ShellHeight
                // So LugTopDist <= ShellHeight - LugSpacing - LugHoleDiam/2
                const maxVal = values.ShellHeight - values.LugSpacing - (values.LugHoleDiam / 2);
                return Math.max(0.5, maxVal);
            }
            
            if (key === 'LugSpacing') {
                // LugTopDist + LugSpacing + LugHoleDiam/2 <= ShellHeight
                // So LugSpacing <= ShellHeight - LugTopDist - LugHoleDiam/2
                const maxVal = values.ShellHeight - values.LugTopDist - (values.LugHoleDiam / 2);
                return Math.max(0.5, maxVal);
            }
            
            return param.max;
        }

        // Validate all parameters
        function validateParameters() {
            const values = getCurrentValues();
            const errors = {};
            let isValid = true;

            for (const [key, param] of Object.entries(config.parameters)) {
                const value = values[key];
                const min = param.min;
                const max = getDynamicMax(key, values) ?? param.max;
                
                let error = null;
                
                if (isNaN(value) || value === '') {
                    error = 'Please enter a valid number';
                } else if (min !== null && min !== undefined && value < min) {
                    const unit = param.unit || '';
                    error = `Minimum is ${min}${unit ? ' ' + unit : ''}`;
                } else if (max !== null && max !== undefined && value > max) {
                    const unit = param.unit || '';
                    error = `Maximum is ${max.toFixed(2)}${unit ? ' ' + unit : ''}`;
                }
                
                // Update UI for this parameter
                const group = document.getElementById(key)?.closest('.parameter-group');
                const errorDiv = group?.querySelector('.parameter-error');
                const rangeSpan = group?.querySelector('.dynamic-range');
                
                // Update dynamic range display
                if (rangeSpan && param.dynamicMax) {
                    const unit = param.unit || '';
                    rangeSpan.textContent = `${param.min}‚Äì${max.toFixed(1)}${unit ? ' ' + unit : ''}`;
                }
                
                if (error) {
                    errors[key] = error;
                    isValid = false;
                    group?.classList.add('invalid');
                    if (errorDiv) errorDiv.textContent = error;
                } else {
                    group?.classList.remove('invalid');
                }
            }
            
            // Update validation summary and submit button
            const validationSummary = document.getElementById('validationSummary');
            const submitBtn = document.getElementById('submitBtn');
            
            if (isValid) {
                validationSummary?.classList.remove('show');
                submitBtn.disabled = false;
            } else {
                validationSummary?.classList.add('show');
                submitBtn.disabled = true;
            }
            
            return isValid;
        }

        function renderParameters() {
            const grid = document.getElementById('parametersGrid');
            grid.innerHTML = '';

            for (const [key, param] of Object.entries(config.parameters)) {
                const group = document.createElement('div');
                group.className = 'parameter-group';
                const label = param.label || key;
                const description = param.description || '';
                
                // Determine input type and formatting based on parameter type
                const isNumeric = param.type === 'number' || param.type === 'dimension';
                const unitSuffix = param.unit ? `<span class="unit-suffix">${param.unit}</span>` : '';
                const defaultDisplay = param.unit ? `${param.default} ${param.unit}` : param.default;
                
                // Build range note
                let rangeNote = '';
                if (param.min !== null && param.min !== undefined && param.max !== null && param.max !== undefined) {
                    const unit = param.unit || '';
                    rangeNote = ` (${param.min}‚Äì${param.max}${unit ? ' ' + unit : ''})`;
                } else if (param.min !== null && param.min !== undefined) {
                    const unit = param.unit || '';
                    rangeNote = ` (min: ${param.min}${unit ? ' ' + unit : ''})`;
                } else if (param.max !== null && param.max !== undefined) {
                    const unit = param.unit || '';
                    rangeNote = ` (max: ${param.max}${unit ? ' ' + unit : ''})`;
                }
                // For dynamic constraints, calculate initial max and show it
                if (param.dynamicMax) {
                    const unit = param.unit || '';
                    // Calculate initial max using defaults
                    const defaults = {};
                    for (const [k, p] of Object.entries(config.parameters)) {
                        defaults[k] = p.default;
                    }
                    const initialMax = getDynamicMax(key, defaults);
                    rangeNote = ` (<span class="dynamic-range">${param.min}‚Äì${initialMax.toFixed(1)}${unit ? ' ' + unit : ''}</span>)`;
                }
                
                group.innerHTML = `
                    <label data-description="${description}">${label}<span class="label-tooltip">${description}</span></label>
                    <div class="input-with-unit">
                        <input 
                            type="text"
                            inputmode="${isNumeric ? 'decimal' : 'text'}"
                            id="${key}" 
                            value="${param.default}"
                            placeholder="${param.default}"
                        >
                        ${unitSuffix}
                    </div>
                    <div class="parameter-note">Default: ${defaultDisplay}${rangeNote}</div>
                    <div class="parameter-error"></div>
                `;
                grid.appendChild(group);

                // Add live preview update on input change
                const input = group.querySelector('input');
                
                // For number/dimension inputs, strip any non-numeric characters
                if (param.type === 'number' || param.type === 'dimension') {
                    input.addEventListener('input', (e) => {
                        // Allow only digits, decimal point, and minus sign at start
                        const cleaned = e.target.value.replace(/[^0-9.\-]/g, '')
                            .replace(/(?!^)-/g, '')  // minus only at start
                            .replace(/(\..*)\./g, '$1');  // only one decimal
                        if (cleaned !== e.target.value) {
                            e.target.value = cleaned;
                        }
                    });
                }
                
                input.addEventListener('input', () => {
                    debouncedUpdatePreview();
                    validateParameters();
                });
                input.addEventListener('change', () => {
                    debouncedUpdatePreview();
                    validateParameters();
                });
                
                // Label click to show tooltip
                const labelEl = group.querySelector('label');
                const tooltip = group.querySelector('.label-tooltip');
                if (labelEl && tooltip) {
                    labelEl.addEventListener('click', (e) => {
                        e.preventDefault();
                        // Hide all other tooltips first
                        document.querySelectorAll('.label-tooltip.show').forEach(t => {
                            if (t !== tooltip) t.classList.remove('show');
                        });
                        tooltip.classList.toggle('show');
                    });
                }
            }
            
            // Close tooltips when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('label')) {
                    document.querySelectorAll('.label-tooltip.show').forEach(t => {
                        t.classList.remove('show');
                    });
                }
            });
            
            // Initial validation
            validateParameters();
        }

        function setupEventListeners() {
            const submitBtn = document.getElementById('submitBtn');
            const resetBtn = document.getElementById('resetBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const previewImage = document.getElementById('previewImage');
            const previewFrame = document.getElementById('previewFrame');
            const previewEmpty = document.getElementById('previewEmpty');

            previewImage.addEventListener('load', () => {
                previewFrame.classList.add('has-image');
                previewEmpty.style.display = 'none';
            });

            previewImage.addEventListener('error', () => {
                previewFrame.classList.remove('has-image');
                previewEmpty.style.display = 'block';
            });

            // Submit handling
            submitBtn.addEventListener('click', handleSubmit);
            resetBtn.addEventListener('click', handleReset);
            downloadBtn.addEventListener('click', handleDownload);
        }

        async function handleSubmit() {
            const parameters = getParameters();

            console.log('üì§ Sending parameters:', JSON.stringify(parameters, null, 2));
            
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.classList.add('loading');
            document.getElementById('downloadSection').style.display = 'none';

            try {
                showStatus('Submitting to Autodesk...', 'pending', true);

                const response = await fetch('/api/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parameters })
                });

                if (!response.ok) {
                    throw new Error(`Submission failed: ${response.statusText}`);
                }

                const data = await response.json();
                currentJobId = data.workItemId;

                showStatus(
                    `‚úì Job submitted! ID: <div class="status-id">${currentJobId}</div>
                    Processing... (this may take 2-5 minutes)`,
                    'pending',
                    true
                );

                // Poll for status
                pollJobStatus();
            } catch (error) {
                console.error('Error submitting job:', error);
                showStatus(`Submission error: ${error.message}`, 'error');
                submitBtn.disabled = false;
                submitBtn.classList.remove('loading');
            }
        }

        async function pollJobStatus() {
            if (!currentJobId) return;

            try {
                const response = await fetch(`/api/job-status/${currentJobId}`);
                if (!response.ok) throw new Error('Failed to get status');

                const data = await response.json();

                // Update progress bar if available
                if (data.progress !== undefined) {
                    const progressFill = document.querySelector('.progress-fill');
                    if (progressFill) {
                        progressFill.style.width = `${data.progress}%`;
                    }
                }

                if (data.status === 'success') {
                    showStatus(
                        '‚úì Processing complete! Your modified drum parameters have been applied.',
                        'success'
                    );
                    document.getElementById('submitBtn').disabled = false;
                    document.getElementById('submitBtn').classList.remove('loading');
                    document.getElementById('downloadSection').style.display = 'block';
                    showPreview(currentJobId);
                } else if (data.status === 'failed' || data.status === 'cancelled') {
                    showStatus(`‚úó Job ${data.status}. Please try again.`, 'error');
                    document.getElementById('submitBtn').disabled = false;
                    document.getElementById('submitBtn').classList.remove('loading');
                    clearPreviewRefresh();
                } else {
                    // Still pending - update status message
                    const progressPercent = data.progress !== undefined ? ` ${data.progress}%` : '';
                    showStatus(
                        `‚è≥ Processing...${progressPercent}<br><small>Job ID: ${currentJobId}</small>`,
                        'pending',
                        true
                    );
                    // Check again in 1 second
                    setTimeout(pollJobStatus, 1000);
                }
            } catch (error) {
                console.error('Error polling status:', error);
                // Continue polling on error
                setTimeout(pollJobStatus, 2000);
            }
        }

        function handleReset() {
            currentJobId = null;
            document.getElementById('submitBtn').disabled = false;
            document.getElementById('submitBtn').classList.remove('loading');
            document.getElementById('status').classList.remove('show');
            document.getElementById('downloadSection').style.display = 'none';
            if (previewObjectUrl) {
                URL.revokeObjectURL(previewObjectUrl);
                previewObjectUrl = null;
            }
            document.getElementById('previewLink').setAttribute('href', '#');
            document.getElementById('previewLink').style.display = 'none';
            clearPreviewRefresh();
            renderParameters();
            // Refresh live preview with default values
            updateLivePreview();
        }

        function clearPreviewRefresh() {
            if (previewRefreshTimer) {
                clearInterval(previewRefreshTimer);
                previewRefreshTimer = null;
            }
        }

        async function updatePreviewImage(baseUrl) {
            if (previewRequestInFlight) return;
            previewRequestInFlight = true;

            const previewFrame = document.getElementById('previewFrame');
            const previewImage = document.getElementById('previewImage');
            const previewEmpty = document.getElementById('previewEmpty');

            try {
                const response = await fetch(`${baseUrl}?t=${Date.now()}`, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Preview fetch failed: ${response.status}`);
                }

                const contentType = response.headers.get('content-type') || '';
                const blob = await response.blob();

                if (previewObjectUrl) {
                    URL.revokeObjectURL(previewObjectUrl);
                }

                previewObjectUrl = URL.createObjectURL(blob);
                previewImage.src = previewObjectUrl;
                previewImage.dataset.contentType = contentType;
                previewFrame.classList.add('has-image');
                previewEmpty.style.display = 'none';

                if (!contentType.includes('svg')) {
                    clearPreviewRefresh();
                }
            } catch (error) {
                console.error('Error fetching preview:', error);
            } finally {
                previewRequestInFlight = false;
            }
        }

        function showPreview(jobId) {
            const previewLink = document.getElementById('previewLink');
            const baseUrl = `/api/preview/${jobId}`;

            previewLink.href = `${baseUrl}?full=1`;
            previewLink.style.display = 'inline';

            clearPreviewRefresh();
            // Refresh the preview from the job endpoint
            updatePreviewImage(baseUrl);
        }

        async function handleDownload() {
            if (!currentJobId) {
                showStatus('No job ID available for download', 'error');
                return;
            }

            try {
                const downloadBtn = document.getElementById('downloadBtn');
                downloadBtn.disabled = true;
                downloadBtn.classList.add('loading');
                downloadBtn.textContent = '‚¨áÔ∏è Downloading...'

                const response = await fetch(`/api/download/${currentJobId}`);
                if (!response.ok) {
                    throw new Error(`Download failed: ${response.statusText}`);
                }

                // Get filename from response header or use default
                const contentDisposition = response.headers.get('content-disposition');
                let filename = 'modified_drum.stl';
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                    if (filenameMatch) filename = filenameMatch[1];
                }

                // Convert response to blob and trigger download
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);

                downloadBtn.disabled = false;
                downloadBtn.classList.remove('loading');
                downloadBtn.textContent = '‚¨áÔ∏è Download Modified Drum File';
            } catch (error) {
                console.error('Error downloading file:', error);
                showStatus(`Download error: ${error.message}`, 'error');
                const downloadBtn = document.getElementById('downloadBtn');
                downloadBtn.disabled = false;
                downloadBtn.classList.remove('loading');
                downloadBtn.textContent = '‚¨áÔ∏è Download Modified Drum File';
            }
        }

        function showStatus(message, type, showProgress = false) {
            const status = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            const progress = document.getElementById('progress');

            status.className = `status show ${type}`;
            statusText.innerHTML = message;
            progress.style.display = showProgress ? 'block' : 'none';
        }

        // Auto-reload when server restarts (dev mode only)
        // Requires multiple consecutive failures to avoid false positives during navigation
        let serverDownCount = 0;
        const REQUIRED_DOWN_COUNT = 3; // Must fail 3 times in a row (1.5 seconds)
        
        setInterval(async () => {
            // Don't poll when page is hidden (user navigated away)
            if (document.hidden) {
                serverDownCount = 0;
                return;
            }
            
            try {
                const response = await fetch('/api/health');
                if (response.ok) {
                    if (serverDownCount >= REQUIRED_DOWN_COUNT) {
                        console.log('Server is back online, reloading page...');
                        window.location.reload();
                    }
                    serverDownCount = 0;
                } else {
                    serverDownCount++;
                }
            } catch (error) {
                serverDownCount++;
            }
        }, 500); // Check every 500ms

        // Fade in page once loaded to avoid layout shift flash
        window.addEventListener('load', () => {
            document.body.classList.add('loaded');
        });
        // Fallback in case load event already fired
        if (document.readyState === 'complete') {
            document.body.classList.add('loaded');
        }
    </script>
</body>
</html>
